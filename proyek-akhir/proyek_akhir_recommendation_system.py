# -*- coding: utf-8 -*-
"""Proyek Akhir-Recommendation System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lg6Ub9H4i7_idCO3i4Zl1Qha-VSwX6pw

# Proyek Recommendation System: Movie Lens Small Latest Dataset
- **Nama:** Meilani Kizana
- **Email:** meilanikizana@gmail.com
- **ID Dicoding:** Meilani Kizana

## Import Library

Tahapan ini merupakan tahap untuk melakukan import semua library yang akan digunakan selama proyek.
"""

import os
import numpy as np
import pandas as pd
from google.colab import files
import seaborn as sns
import matplotlib.pyplot as plt
import tensorflow as tf
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.layers import Dense, Embedding, Flatten
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam

"""## Data Loading

Tahapan ini merupakan tahap untuk mengunggah dataset dari Kaggle dan menyimpannya ke dataframe.
"""

files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d shubhammehta21/movie-lens-small-latest-dataset
!unzip movie-lens-small-latest-dataset.zip

"""Dataset yang diunggah dari kaggle terdiri atas 5 file yaitu:
- README.txt: Berisi tentang informasi terkait dataset
- links.csv: Berisi tentang id film dengan id IMDB dan id TMDB untuk memudahkan koneksi dengan sumber data lain
- movies.csv: Berisi tentang informasi film
- ratings.csv: Berisi tentang informasi rating film oleh pengguna
- tags.csv: Berisi tentang informasi tag film oleh pengguna
"""

links = pd.read_csv('links.csv')
movies = pd.read_csv('movies.csv')
ratings = pd.read_csv('ratings.csv')
tags = pd.read_csv('tags.csv')

print('Jumlah data id film: ', len(links.movieId.unique()))
print('Jumlah data film: ', len(movies.movieId.unique()))
print('Jumlah data rating: ', len(ratings.userId))
print('Jumlah pengguna yang memberikan rating: ', len(ratings.userId.unique()))
print('Jumlah film yang diberikan rating: ', len(ratings.movieId.unique()))
print('Jumlah pengguna yang memberikan tag: ', len(tags.userId.unique()))
print('Jumlah film yang diberikan tag: ', len(tags.movieId.unique()))

"""Tahap diatas digunakan untuk menyimpan setiap file ke dalam dataframe masing-masing dan menampilkan beberapa sekilas informasi mengenai jumlah data.

## Univariate Exploratory Data Analysis

Tahapan ini merupakan tahap ekplorasi data untuk dapat memahami setiap data dengan lebih baik.
"""

links.info()

"""'links' yang berasal dari file links.csv berisi 3 kolom yaitu movieId, imdbId, dan tmdbId dengan total baris/data yaitu 9742. Data ini berguna sebagai jembatan yang menghubungkan data film dari dataset ini dengan dataset lain. Namun pada proyek ini, saya hanya menggunakan dataset ini dan tidak menggabungkan data dengan dataset lain sehingga data pada 'links' tidak akan digunakan."""

movies.info()

"""'movies' yang berasal dari file movies.csv berisi 3 kolom yaitu movieId, title, dan genres dengan total baris/data yaitu 9742. Data ini merupakan data yang berisikan informasi film seperti id, judul, dan genrenya. Data ini akan digunakan untuk membangun sistem rekomendasi content based filtering."""

print('Banyak film: ', len(movies.movieId.unique()))
print('Judul film: ', movies.title.unique())

print('\nBanyak genre: ', len(movies.genres.unique()))
print('Genre film: ', movies.genres.unique())

"""Jumlah film yang terdapat dalam movies adalah 9708 dan genrenya 950. Genre setiap film terdiri dari kombinasi beberapa genre, bukan hanya satu genre. Sehingga akan diperlukan persiapan sebelum melakukan modelling."""

ratings.info()

"""'ratings' yang berasal dari file ratings.csv berisi 4 kolom yaitu userId, movieId, rating, dan timestamp dengan total baris/data yaitu 100836. Data ini merupakan data yang berisikan informasi rating film yang diberikan oleh pengguna. Data ini akan digunakan untuk membangun sistem rekomendasi collaborative filtering."""

ratings.describe()

"""Dari tahap diatas, dapat diketahui rentang rating adalah 0-5, dengan rating paling kecil yang diberikan oleh pengguna adalah 0.5 dan paling besar yaitu 5."""

print('Jumlah user yang memberikan rating: ', len(ratings.userId.unique()))
print('Jumlah film yang diberikan rating: ', len(ratings.movieId.unique()))
print('Jumlah data rating: ', len(ratings))

"""Tahapan diatas guna mengetahui jumlah pengguna dan jumlah film yang terdapat pada data 'ratings'. Jumlah pengguna yang memberikan rating adalah 610. Jumlah film yang diberikan rating adalah 9724. Dengan total seluruh data adalah 100836. Artinya 1 pengguna memberikan ratin pada lebih dari 1 film. Serta 1 film memiliki rating dari berbagai pengguna."""

tags.info()

tags.head()

"""'tags' yang berasal dari file tags.csv berisi 4 kolom yaitu userId, movieId, tag, dan timestamp dengan total baris/data yaitu 3683. Data ini merupakan data yang berisikan informasi tag film yang diberikan oleh pengguna. Namun pada proyek ini, saya hanya menggunakan genre sebagai basis untuk content based filtering, sehingga data ini tidak digunakan."""

print("Nilai kosong pada data movies:")
print(movies.isnull().sum())

print("\nNilai kosong pada data ratings:")
print(ratings.isnull().sum())

print("Jumlah data duplikat pada movies:", movies.duplicated().sum())
print("Jumlah data duplikat pada ratings:", ratings.duplicated().sum())

"""Tahap diatas digunakan untuk mengidentifikasi nilai kosong dan data duplikat pada data movies dan ratings yang akan digunakan pada proyek kali ini. Dari hasil dapat dilihat bahwa tidak terdapat nilai kosong maupun data duplikat pada kedua data tersebut.

### Visualisasi Data
"""

genre_counts = movies['genres'].str.get_dummies(sep='|').sum().sort_values(ascending=False)
genre_df = genre_counts.reset_index()
genre_df.columns = ['Genre', 'Jumlah']

plt.figure(figsize=(10, 4))
sns.barplot(data=genre_df, x='Genre', y='Jumlah', palette='Set2', hue='Genre')

plt.title('Distribusi Genre Film')
plt.xlabel('Genre Film')
plt.ylabel('Jumlah Film')
plt.xticks(rotation=45)
plt.show()

movies[movies['genres'] == '(no genres listed)']

"""Tahap diatas digunakan untuk menampilkan visualisasi dari distribusi genre dalam data. Dari hasilnya dapat diketahui bahwa genre drama dan comedy cukup mendominasi jumlahnya. Selain itu, terdapat (no genres listed) dalam visualiasi diatas. Hal ini menunjukkan terdapat film yang belum diberikan genre. Hal ini akan ditangani pada tahapan persiapan data."""

rating_counts = ratings['rating'].value_counts().sort_index()
rating_df = rating_counts.reset_index()
rating_df.columns = ['Rating', 'Jumlah']

plt.figure(figsize=(10, 4))
sns.barplot(data=rating_df, x='Rating', y='Jumlah', palette='Set2', hue='Rating')

plt.title('Distribusi Rating Film')
plt.xlabel('Rating Film')
plt.ylabel('Jumlah')
plt.xticks(rotation=45)
plt.legend().set_visible(False)
plt.show()

"""Tahap diatas digunakan untuk menampilkan visualisasi dari distribusi rating film dalam data. Dari hasilnya dapat diketahui bahwa rating 3.0 dan 4.0 cukup mendominasi jumlahnya. Adapun rating 0.5 dan 1.5 memiliki jumlah yang paling sedikit.

## Data Preparation

Tahapan ini merupakan tahap untuk mempersiapkan data sebelum masuk ke tahap modelling. Proyek ini akan membangun sistem rekomendasi dengan content based filtering dan collaborative filtering, sehingga persiapan data juga dipisahkan berdasarkan dua metode pendekatan tersebut.

### Content Based Filtering Data Preparation

Pendekatan content based filtering yang diterapkan pada proyek ini adalah berdasarkan genre film sehingga data yang digunakan adalah 'movies'. Setelah dilakukan ekplorasi data sebelumnya, dapat diketahui bahwa data 'movies' tidak memiliki nilai kosong dan data duplikat, sehingga tahapan ini berisikan tahap untuk mengatasi nilai genre yang kurang yaitu '(no genres listed)' serta tf-idf vectorizer untuk menemukan representasi fitur penting dari setiap kombinasi genre.
"""

movies = movies[movies['genres'] != '(no genres listed)']

genre_counts = movies['genres'].str.get_dummies(sep='|').sum().sort_values(ascending=False)
genre_df = genre_counts.reset_index()
genre_df.columns = ['Genre', 'Jumlah']

plt.figure(figsize=(10, 4))
sns.barplot(data=genre_df, x='Genre', y='Jumlah', palette='Set2', hue='Genre')

plt.title('Distribusi Genre Film')
plt.xlabel('Genre Film')
plt.ylabel('Jumlah Film')
plt.xticks(rotation=45)
plt.show()

"""Setelah dihapus, dilakukan pengecekan kembali melalui visualisasi untuk memastikan bahwa setiap data dengan genre yang tidak sesuai sudah berhasil ditangani. Dari hasil visualisasi diatas, dapat dilihat bahwa nilai '(no genres listed)' sudah tidak ada."""

tfidf = TfidfVectorizer()

tfidf.fit(movies['genres'])

tfidf.get_feature_names_out()

tfidf_matrix = tfidf.fit_transform(movies['genres'])

tfidf_matrix.shape

tfidf_matrix.todense()

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tfidf.get_feature_names_out(),
    index=movies.title
).sample(21, axis=1).sample(10, axis=0)

cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

cosine_sim_df = pd.DataFrame(cosine_sim, index=movies['title'], columns=movies['title'])
print('Shape:', cosine_sim_df.shape)

cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Tahapan diatas terdiri dari beberapa tahap berikut:
1. Identifikasi Genre Film: mengubah data teks (genre) menjadi representasi numerik (TF-IDF matrix)
2. Fit dan Transform ke Bentuk Matriks: hasil ukuran matriks (9708, 21) yang artinya terdapat 9708 film dan 21 jenis genre
3. Mengubah Vektor TF-IDF dalam Bentuk Matriks: menggunakan fungsi todense()
4. Menampilkan Matriks TF-IDF untuk Beberapa Film terhadap Genre
5. Menghitung Derajat Kesamaan: menggunakan cosine_similarity dan menghasilkan array matriks kesamaan antar film
6. Menampilkan Matriks Kesamaan antar Film

### Collaborative Filtering Data Preparation

Pendekatan collaborative filtering yang diterapkan pada proyek ini adalah berdasarkan rating yang diberikan oleh pengguna sehingga data yang digunakan adalah 'ratings' dan 'movies'. Setelah dilakukan ekplorasi data sebelumnya, dapat diketahui bahwa data tersebut tidak memiliki missing values dan data duplikat. Maka tahapan ini terdiri dari encoding, mapping, normalisasi rating, dan pembagian data training dan data validasi.
"""

user_ids = ratings['userId'].unique().tolist()
print('list userId: ', user_ids)

user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}
print('encoded userID : ', user_to_user_encoded)

user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}
print('encoded angka ke userID: ', user_encoded_to_user)

movie_ids = ratings['movieId'].unique().tolist()

movie_to_movie_encoded = {x: i for i, x in enumerate(movie_ids)}

movie_encoded_to_movie = {i: x for i, x in enumerate(movie_ids)}

"""Tahap diatas adalah tahap encode/menyandikan fitur 'userId' dan 'movieId' ke dalam indeks integer."""

ratings['user'] = ratings['userId'].map(user_to_user_encoded)

ratings['movie'] = ratings['movieId'].map(movie_to_movie_encoded)

"""Setelah tahapan encode, tahap diatas digunakan untuk mapping hasil encode ke dalam dataframe 'ratings'."""

num_users = len(user_to_user_encoded)
num_movie = len(movie_encoded_to_movie)

ratings['rating'] = ratings['rating'].values.astype(np.float32)
min_rating = min(ratings['rating'])
max_rating = max(ratings['rating'])

print('Jumlah pengguna: {}\nJumlah film: {}\nRating terendah: {}\nRating tertinggi: {}'.format(
    num_users, num_movie, min_rating, max_rating
))

"""Tahap diatas digunakan untuk mengecek beberapa hal mengenai data 'ratings' seperti jumlah data pengguna, jumlah data film, serta nilai rating terendah dan tertinggi."""

ratings = ratings.sample(frac=1, random_state=42)
ratings

"""Tahap diatas digunakan untuk mengecek data 'ratings'."""

x = ratings[['user', 'movie']].values

y = ratings['rating'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values

train_indices = int(0.8 * ratings.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)

print(x, y)

"""Tahap diatas merupakan tahap untuk membuat vairabel X dan variabel Y dan kemudian membagi dataset menjadi data pelatihan dan data validasi dengan perbandingan 80:20.

## Model Development

### Content Based Filtering
"""

def movie_recommendations(judul, similarity_data=cosine_sim_df, items=movies[['title', 'genres']], k=5):
    """
    Rekomendasi film berdasarkan kemiripan dataframe

    Parameter:
    ---
    judul : tipe data string (str)
            Judul Film(index kemiripan dataframe)
    similarity_data : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan resto sebagai
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    k : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---


    Pada index ini, kita mengambil k dengan nilai similarity terbesar
    pada index matrix yang diberikan (i).
    """

    index = similarity_data.loc[:,judul].to_numpy().argpartition(
        range(-1, -k, -1))

    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    closest = closest.drop(judul, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""Tahap diatas adalah tahap pembuatan fungsi movie_recommendations dengan menggunakan beberapa parameter yaitu:
1. judul: judul film (index kemiripan dataset)
2. similarity_data: dataframe mengenai similarity/kesamaan yang telah didefinisikan sebelumnya menggunakan cosine
3. items: nama dan fitur yang digunakan untuk mendefinisikan kemiripan yaitu judul film dan genrenya
4. k: banyak rekomendasi yang diberikan adalah 5

Fungsi diatas akan berguna sebagai pemberi rekomendasi film dimana fungsi tersebut akan mengembalikan 5 film yang memiliki tingkat kemiripan genre tertinggi dengan film yang dipilih.

#### Mendapatkan Rekomendasi Film Berdasarkan Genre
"""

movies[movies.title.eq('Pixel Perfect (2004)')]

"""Tahap diatas digunakan untuk mengidentifikasi terlebih dahulu film yang akan kita gunakan untuk mencari rekomendasi film lainnya. Dari hasilnya, film 'Pixel Perfect (2004)' bergenre Children, Comedy, dan Sci-Fi."""

movie_recommendations('Pixel Perfect (2004)')

"""Tahap diatas adalah tahap untuk mendapatkan rekomendasi film dengan menggunakan fungsi yang telah dibentuk sebelumnya. Hasilnya menunjukkan 5 film lainnya yang memiliki genre serupa yaitu sekitaran Children, Comedy, dan Sci-Fi.

### Collaborative Filtering
"""

class RecommenderNet(Model):

  def __init__(self, num_users, num_movie, embedding_size):
    super(RecommenderNet, self).__init__()
    self.num_users = num_users
    self.num_movie = num_movie
    self.embedding_size = embedding_size
    self.user_embedding = Embedding(
        num_users,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.user_bias = Embedding(num_users, 1)
    self.movie_embedding = Embedding(
        num_movie,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.movie_bias = Embedding(num_movie, 1)

  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:,0])
    user_bias = self.user_bias(inputs[:, 0])
    movie_vector = self.movie_embedding(inputs[:, 1])
    movie_bias = self.movie_bias(inputs[:, 1])

    dot_user_movie = tf.tensordot(user_vector, movie_vector, 2)

    x = dot_user_movie + user_bias + movie_bias

    return tf.nn.sigmoid(x)

"""Tahap diatas merupakan tahap pembuatan kelas RecommenderNet dengan keras Model class. Pada tahap ini, model menghitung skor kecocokan antara pengguna dan film dengan teknik embedding. Tahapannya yaitu:
1. Embedding Data Pengguna dan Data Film
2. Menambahkan Bias untuk Setiap Pengguna dan Film
3. Operasi Perkalian Dot Product antara Embedding User dan Film
4. Fungsi Aktivasi Sigmoid untuk Menentukan Skor Kecocokan dalam Skala [0, 1]
"""

model = RecommenderNet(num_users, num_movie, 100)

model.compile(
    optimizer = Adam(learning_rate=0.001),
    loss = tf.keras.losses.BinaryCrossentropy(),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

"""Tahap diatas merupakan tahapan untuk melakukan compile terhadap model. Model ini menggunakan Adam sebagai optimizer, BinaryCrossEntropy sebagai penghitung loss, dan RMSE sebagai metrik evaluasi."""

history = model.fit(
    x = x_train,
    y = y_train,
    batch_size = 8,
    epochs = 20,
    validation_data = (x_val, y_val)
)

"""Tahap diatas merupakan tahap pelatihan model. Pelatihan model menggunakan ukuran batch yaitu 8 dan 20 epoch. Nilai RMSE pada data latih adalah '0.1887' dan pada data validasi adalah '0.2019'. Hal ini menunjukkan bahwa model sudah cukup baik dan tidak mengalami overfitting pada data latih. Penurunan nilai RMSE dari epoch awal hingga akhir juga menandakan proses training yang cukup smooth."""

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('Metrik RMSE')
plt.ylabel('RMSE')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'], loc='upper right')
plt.show()

"""Tahap diatas digunakan untuk menampilkan visualiasi metrik evaluasi dari pelatihan model sebelumnya. Dari hasil ini, dapat dilihat bahwa proses training model cukup baik, tidak mengalami overfitting, dan model konvergen.

#### Mendapatkan Rekomendasi Film Berdasarkan Rating Sebelumnya
"""

movie_df = movies
df = pd.read_csv('ratings.csv')

user_id = df.userId.sample(1).iloc[0]
movie_rated_by_user = df[df.userId == user_id]

movie_not_rated = movie_df[~movie_df['movieId'].isin(movie_rated_by_user.movieId.values)]['movieId']
movie_not_rated = list(
    set(movie_not_rated)
    .intersection(set(movie_to_movie_encoded.keys()))
)

movie_not_rated = [[movie_to_movie_encoded.get(x)] for x in movie_not_rated]
user_encoder = user_to_user_encoded.get(user_id)
user_movie_array = np.hstack(
    ([[user_encoder]] * len(movie_not_rated), movie_not_rated)
)

"""Tahap diatas merupakan tahap untuk mengambil satu sampel pengguna secara acak yang nantinya akan dianalisis dan diberikan rekomendasi film berdasarkan riwayat rating yang pernah diberikan oleh pengguna. Selain mengambil satu pengguna, hal yang dilakukan pada tahap ini adalah membuat vaiabel film yang belum diberikan penilaian oleh pengguna. Hal ini diperlukan karena film yang akan direkomendasikan tentu idealnya adalah film yang belum pernah ditonton oleh pengguna. Jika film telah dirating oleh pengguna, artinya pengguna telah menonton film tersebut maka film-film yang sudah dirating akan dikecualikan dari rekomendasi."""

rating = model.predict(user_movie_array).flatten()

top_ratings_indices = rating.argsort()[-10:][::-1]
recommended_movie_ids = [
    movie_encoded_to_movie.get(movie_not_rated[x][0]) for x in top_ratings_indices
]

print('Rekomendasi Film untuk Pengguna dengan ID: {}'.format(user_id))
print('\n5 Film dengan Rating Tertinggi oleh Pengguna')
print('----' * 8)

top_movie_user = (
    movie_rated_by_user.sort_values(
        by = 'rating',
        ascending=False
    )
    .head(5)
    .movieId.values
)

movie_df_rows = movie_df[movie_df['movieId'].isin(top_movie_user)]
for row in movie_df_rows.itertuples():
    print(row.title, ':', row.genres)

print('\nTop 10 Film Hasil Rekomendasi')
print('----' * 8)

recommended_movie = movie_df[movie_df['movieId'].isin(recommended_movie_ids)]
for row in recommended_movie.itertuples():
    print(row.title, ':', row.genres)

"""Tahap diatas adalah tahap untuk memperoleh 10 rekomendasi film untuk pengguna berdasarkan riwayat film yang dirating oleh pengguna. Tahapan diatas menampilkan id pengguna, 5 film dengan rating tertinggi dari pengguna, dan 10 rekomendasi film untuk pengguna. Hasil dari tahapan diatas adalah:
1. Pengguna yang terpilih secara acak adalah pengguna dengan id 599.
2. Film dengan rating tertinggi yang diberikan oleh pengguna berkisar pada genre Action, Adventure, Comedy, Crime, Drama, Sci-Fi, Romance, dan Thiller.
3. Hasil rekomendasi film yang diberikan untuk pengguna cukup selaras dengan film yang dirating tinggi oleh pengguna yaitu berkisar pada genre Drama, Comedy, Adventure, dan Crime.
"""